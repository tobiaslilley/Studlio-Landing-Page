<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocols - STUDL.IO</title>
    <meta name="description" content="Browse and explore health protocols available in STUDL.IO">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="Assets/Website-Favicon-Color.svg">
    
    <!-- Preload fonts for better performance -->
    <link rel="preload" href="Assets/Sanger.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="Assets/Cartograph-Sans-Light.ttf" as="font" type="font/ttf" crossorigin>
    
    <!-- CSS -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- Supabase -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://htizxlmrzfehvpupvwbn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh0aXp4bG1yemZlaHZwdXB2d2JuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMTY3NDEsImV4cCI6MjA3MTY5Mjc0MX0.pBC8d5zXG6DZeU3atMZEqOgY4WG8Mh7T0m2tVk5CcUY';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Check authentication status
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuthStatus();
        });
        
        async function checkAuthStatus() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                
                if (session) {
                    updateNavForLoggedInUser();
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
            }
        }
        
        function updateNavForLoggedInUser() {
            const adminLink = document.querySelector('a[href="admin.html"]');
            if (adminLink) {
                adminLink.textContent = 'Admin Dashboard';
                adminLink.style.color = '#28a745';
                adminLink.style.fontWeight = '600';
            }
        }
    </script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="nav-logo-img">
                </a>
            </div>
            <div class="nav-links">
                <a href="index.html#features">Features</a>
                <a href="index.html#download">Download</a>
                <a href="index.html#contact">Contact</a>
                <a href="protocols.html" class="active">Protocols</a>
            </div>
        </div>
    </nav>

    <!-- Development Status Banner -->
    <div class="dev-banner">
        <div class="container">
            <p>üöß <strong>Coming Soon!</strong> STUDL.IO is currently in development and will be available soon. Stay tuned for updates!</p>
        </div>
    </div>

    <!-- Protocols Section -->
    <section class="protocols">
        <div class="container">
            <div class="protocols-header">
                <h1 class="section-title">Health Protocols</h1>
                <p class="protocols-subtitle">Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.</p>
                
                <!-- Search Bar -->
                <div class="search-container">
                    <div class="search-input-wrapper">
                        <input 
                            type="text" 
                            id="searchInput" 
                            class="search-input" 
                            placeholder="Search protocols by name, category, or metrics..."
                            autocomplete="off"
                        >
                        <div class="search-icon">üîç</div>
                    </div>
                    
                    <!-- Filters -->
                    <div class="filter-container">
                        <select id="categoryFilter" class="category-dropdown">
                            <option value="">All Categories</option>
                        </select>
                        <select id="sortFilter" class="category-dropdown">
                            <option value="featured-date">Featured & Date</option>
                            <option value="name-asc">Name (A-Z)</option>
                            <option value="name-desc">Name (Z-A)</option>
                            <option value="date-desc">Date (Newest)</option>
                            <option value="date-asc">Date (Oldest)</option>
                        </select>
                    </div>
                    
                    <div id="searchResults" class="search-results-info"></div>
                </div>
            </div>
            
            <!-- Loading State -->
            <div id="loading" class="loading-state">
                <div class="loading-spinner"></div>
                <p>Loading protocols...</p>
            </div>
            
            <!-- Error State -->
            <div id="error" class="error-state" style="display: none;">
                <div class="error-icon">‚ö†Ô∏è</div>
                <h3>Unable to load protocols</h3>
                <p>There was an error connecting to our database. Please try again later.</p>
                <button onclick="loadProtocols()" class="btn btn-primary">Try Again</button>
            </div>
            
            <!-- Protocols Grid -->
            <div id="protocols-grid" class="protocols-grid" style="display: none;">
                <!-- Protocols will be dynamically inserted here -->
            </div>
            
            <!-- Empty State -->
            <div id="empty-state" class="empty-state" style="display: none;">
                <div class="empty-icon">üìã</div>
                <h3>No protocols available</h3>
                <p>Check back soon for new health protocols!</p>
            </div>
            
            <!-- No Search Results State -->
            <div id="no-search-results" class="no-search-results" style="display: none;">
                <div class="empty-icon">üîç</div>
                <h3>No protocols found</h3>
                <p>Try adjusting your search terms or browse all protocols.</p>
                <button onclick="clearSearch()" class="btn btn-secondary">Clear Search</button>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="footer-logo-img">
                </div>
                <div class="footer-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#download">Download</a>
                    <a href="index.html#contact">Contact</a>
                    <a href="protocols.html">Protocols</a>
                    <a href="admin.html">Admin</a>
                    <a href="privacy-policy.html">Privacy Policy</a>
                    <a href="terms-of-service.html">Terms of Service</a>
                    <a href="https://x.com/studl_io" target="_blank" rel="noopener noreferrer">Follow on X</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 STUDL.IO. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        // Supabase client is already initialized in the head section
        
        // Global variables for search functionality
        let allProtocols = [];
        let allMetricsMap = {};
        
        // Load protocols from Supabase
        async function loadProtocols() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const protocolsGridEl = document.getElementById('protocols-grid');
            const emptyStateEl = document.getElementById('empty-state');
            
            try {
                // Show loading state
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                protocolsGridEl.style.display = 'none';
                emptyStateEl.style.display = 'none';
                
                // Fetch protocols from Supabase
                const { data: protocols, error: protocolsError } = await supabase
                    .from('protocols')
                    .select('*')
                    .order('featured', { ascending: false, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (protocolsError) {
                    throw protocolsError;
                }
                
                // Fetch all health metrics
                const { data: healthMetrics, error: metricsError } = await supabase
                    .from('health_metrics')
                    .select('id, name, unit');
                
                if (metricsError) {
                    throw metricsError;
                }
                
                // Create a map of metric IDs to metric names for quick lookup
                const metricsMap = {};
                if (healthMetrics) {
                    healthMetrics.forEach(metric => {
                        metricsMap[metric.id] = {
                            name: metric.name,
                            unit: metric.unit
                        };
                    });
                }
                
                // Store data globally for search functionality
                allProtocols = protocols || [];
                allMetricsMap = metricsMap;
                
                // Debug: Log featured protocols
                console.log('Featured protocols:', protocols.filter(p => p.featured === true).map(p => p.name));
                
                // Hide loading state
                loadingEl.style.display = 'none';
                
                if (!protocols || protocols.length === 0) {
                    // Show empty state
                    emptyStateEl.style.display = 'block';
                } else {
                    // Sort protocols using the current sort option
                    const sortedProtocols = sortProtocols([...protocols]);
                    
                    // Populate category dropdown
                    populateCategoryDropdown(sortedProtocols);
                    
                    // Display protocols with metric information
                    displayProtocols(sortedProtocols, metricsMap);
                    protocolsGridEl.style.display = 'grid';
                    updateSearchResults(sortedProtocols.length, sortedProtocols.length);
                }
                
            } catch (error) {
                console.error('Error loading protocols:', error);
                
                // Show error state
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
            }
        }
        
        // Display protocols in the grid
        function displayProtocols(protocols, metricsMap) {
            const protocolsGridEl = document.getElementById('protocols-grid');
            
            protocolsGridEl.innerHTML = protocols.map(protocol => {
                // Get the actual metric names for this protocol
                const metricNames = [];
                if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                    protocol.metric_ids.forEach(metricId => {
                        if (metricsMap[metricId]) {
                            metricNames.push(metricsMap[metricId].name);
                        }
                    });
                }
                
                // Generate citations HTML if they exist
                let citationsHtml = '';
                if (protocol.citations && protocol.citations.length > 0) {
                    citationsHtml = `
                        <div class="protocol-citations">
                            <h4 class="citations-title">References:</h4>
                            <ul class="citations-list">
                                ${protocol.citations.map(citation => `
                                    <li class="citation-item">
                                        <a href="${escapeHtml(citation.url)}" target="_blank" rel="noopener noreferrer" class="citation-link">
                                            ${escapeHtml(citation.name)}
                                        </a>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                }
                
                return `
                <div class="protocol-card ${protocol.featured ? 'featured-protocol' : ''}">
                    <div class="protocol-header">
                        <div class="protocol-title-row">
                            <h3 class="protocol-title">${convertUrlsToLinks(escapeHtml(protocol.name || 'Untitled Protocol'))}</h3>
                            ${protocol.featured ? '<span class="featured-badge">‚≠ê Featured</span>' : ''}
                        </div>
                        <div class="protocol-category">${convertUrlsToLinks(escapeHtml(protocol.category || 'General'))}</div>
                    </div>
                    <div class="protocol-content">
                        <p class="protocol-description">${convertUrlsToLinks(escapeHtml(protocol.description || 'No description available.'))}</p>
                        ${citationsHtml}
                        ${protocol.unit && protocol.unit !== '‚Äî' ? `<div class="protocol-detail"><strong>Unit:</strong> ${convertUrlsToLinks(escapeHtml(protocol.unit))}</div>` : ''}
                        ${protocol.default_value ? `<div class="protocol-detail"><strong>Default Value:</strong> ${convertUrlsToLinks(escapeHtml(protocol.default_value))}</div>` : ''}
                        ${metricNames.length > 0 ? `
                            <div class="protocol-detail">
                                <strong>Tracked Metrics:</strong>
                                <div class="metrics-list">
                                    ${metricNames.map(name => `<span class="metric-tag">${escapeHtml(name)}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="protocol-footer">
                        <div class="protocol-meta">
                            <span class="protocol-date">${formatDate(protocol.created_at)}</span>
                        </div>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to convert URLs to clickable links with shortened text
        function convertUrlsToLinks(text) {
            if (!text) return text;
            
            // URL regex pattern - matches http/https URLs
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            
            return text.replace(urlRegex, (url) => {
                // Create a shortened display text
                let displayText = url;
                
                // Remove protocol for display
                if (url.startsWith('https://')) {
                    displayText = url.substring(8);
                } else if (url.startsWith('http://')) {
                    displayText = url.substring(7);
                }
                
                // Truncate if too long (keep first part and last part)
                if (displayText.length > 50) {
                    const firstPart = displayText.substring(0, 30);
                    const lastPart = displayText.substring(displayText.length - 20);
                    displayText = firstPart + '...' + lastPart;
                }
                
                // Return clickable link
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" class="protocol-link">${escapeHtml(displayText)}</a>`;
            });
        }
        
        // Helper function to format date
        function formatDate(dateString) {
            if (!dateString) return 'Unknown date';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }
        
        // Populate category dropdown
        function populateCategoryDropdown(protocols) {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(protocols.map(p => p.category).filter(Boolean))].sort();
            
            // Clear existing options except "All Categories"
            categoryFilter.innerHTML = '<option value="">All Categories</option>';
            
            // Add category options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }
        
        // Sort protocols based on selected sort option
        function sortProtocols(protocols) {
            const sortFilter = document.getElementById('sortFilter');
            const sortOption = sortFilter ? sortFilter.value : 'featured-date';
            
            console.log('Sorting protocols with option:', sortOption);
            
            return protocols.sort((a, b) => {
                switch (sortOption) {
                    case 'featured-date':
                        // Default: Featured first, then by creation date (newest first)
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'name-asc':
                        // Sort by name A-Z
                        return (a.name || '').localeCompare(b.name || '');
                    
                    case 'name-desc':
                        // Sort by name Z-A
                        return (b.name || '').localeCompare(a.name || '');
                    
                    case 'date-desc':
                        // Sort by date newest first
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'date-asc':
                        // Sort by date oldest first
                        return new Date(a.created_at) - new Date(b.created_at);
                    
                    default:
                        // Default sorting
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                }
            });
        }
        
        // Combined search and filter functionality
        function filterProtocols() {
            const searchTerm = document.getElementById('searchInput').value;
            const selectedCategory = document.getElementById('categoryFilter').value;
            
            let filteredProtocols = allProtocols;
            
            // Apply category filter
            if (selectedCategory) {
                filteredProtocols = filteredProtocols.filter(protocol => 
                    protocol.category === selectedCategory
                );
            }
            
            // Apply search filter
            if (searchTerm && searchTerm.trim() !== '') {
                const searchLower = searchTerm.toLowerCase();
                filteredProtocols = filteredProtocols.filter(protocol => {
                    // Search in protocol name
                    if (protocol.name && protocol.name.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in category
                    if (protocol.category && protocol.category.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in description
                    if (protocol.description && protocol.description.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in metric names
                    if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                        const hasMatchingMetric = protocol.metric_ids.some(metricId => {
                            const metric = allMetricsMap[metricId];
                            return metric && metric.name.toLowerCase().includes(searchLower);
                        });
                        if (hasMatchingMetric) {
                            return true;
                        }
                    }
                    
                    // Search in citations
                    if (protocol.citations && protocol.citations.length > 0) {
                        const hasMatchingCitation = protocol.citations.some(citation => 
                            citation.name && citation.name.toLowerCase().includes(searchLower)
                        );
                        if (hasMatchingCitation) {
                            return true;
                        }
                    }
                    
                    return false;
                });
            }
            
            // Apply sorting to filtered protocols
            filteredProtocols = sortProtocols(filteredProtocols);
            
            // Update display
            if (filteredProtocols.length === 0) {
                document.getElementById('protocols-grid').style.display = 'none';
                document.getElementById('no-search-results').style.display = 'block';
            } else {
                displayProtocols(filteredProtocols, allMetricsMap);
                document.getElementById('protocols-grid').style.display = 'grid';
                document.getElementById('no-search-results').style.display = 'none';
            }
            
            updateSearchResults(filteredProtocols.length, allProtocols.length);
        }
        
        // Legacy search function for backward compatibility
        function searchProtocols(searchTerm) {
            filterProtocols();
        }
        
        // Update search results counter
        function updateSearchResults(shown, total) {
            const searchResultsEl = document.getElementById('searchResults');
            if (shown === total) {
                searchResultsEl.textContent = '';
            } else {
                searchResultsEl.textContent = `Showing ${shown} of ${total} protocols`;
            }
        }
        
        // Clear search and filters
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            const categoryFilter = document.getElementById('categoryFilter');
            const sortFilter = document.getElementById('sortFilter');
            searchInput.value = '';
            categoryFilter.value = '';
            sortFilter.value = 'featured-date'; // Reset to default sort
            filterProtocols();
        }
        
        // Load protocols when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadProtocols();
            
            // Add search event listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', () => {
                filterProtocols();
            });
            
            // Add category filter event listener
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.addEventListener('change', () => {
                filterProtocols();
            });
            
            // Add sort filter event listener
            const sortFilter = document.getElementById('sortFilter');
            sortFilter.addEventListener('change', () => {
                filterProtocols();
            });
        });
    </script>
</body>
</html>
