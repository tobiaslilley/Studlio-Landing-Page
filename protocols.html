<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocols - STUDL.IO</title>
    <meta name="description" content="Browse and explore biohacking protocols available in STUDL.IO">
    
    <!-- OpenGraph Meta Tags -->
    <meta property="og:title" content="Biohacking Protocols - STUDL.IO">
    <meta property="og:description" content="Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.">
    <meta property="og:image" content="https://studl.io/Assets/opengraph.png">
    <meta property="og:url" content="https://studl.io/protocols.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="STUDL.IO">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Biohacking Protocols - STUDL.IO">
    <meta name="twitter:description" content="Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.">
    <meta name="twitter:image" content="Assets/opengraph.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="Assets/Website-Favicon-Color.svg">
    
    <!-- Preload fonts for better performance -->
    <link rel="preload" href="Assets/Sanger.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="Assets/Cartograph-Sans-Light.ttf" as="font" type="font/ttf" crossorigin>
    
    <!-- CSS -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- Vercel Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="https://cdn.vercel-insights.com/v1/script.debug.js"></script>
    
    <!-- Supabase -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://htizxlmrzfehvpupvwbn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh0aXp4bG1yemZlaHZwdXB2d2JuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMTY3NDEsImV4cCI6MjA3MTY5Mjc0MX0.pBC8d5zXG6DZeU3atMZEqOgY4WG8Mh7T0m2tVk5CcUY';
        
        // Initialize Supabase client
        let supabase;
        if (window.supabase) {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } else {
            console.error('Supabase client not loaded');
        }
        
        // Check authentication status
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuthStatus();
            initializeMobileNavigation();
        });
        
        // Initialize mobile navigation
        function initializeMobileNavigation() {
            const navToggle = document.querySelector('.nav-toggle');
            const navLinks = document.querySelector('.nav-links');
            
            if (navToggle && navLinks) {
                navToggle.addEventListener('click', () => {
                    const isExpanded = navToggle.getAttribute('aria-expanded') === 'true';
                    navToggle.setAttribute('aria-expanded', !isExpanded);
                    navLinks.classList.toggle('active');
                    
                    // Update button text
                    navToggle.textContent = isExpanded ? '☰' : '✕';
                });
                
                // Close menu when clicking on a link
                navLinks.addEventListener('click', (e) => {
                    if (e.target.tagName === 'A') {
                        navLinks.classList.remove('active');
                        navToggle.setAttribute('aria-expanded', 'false');
                        navToggle.textContent = '☰';
                    }
                });
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!navToggle.contains(e.target) && !navLinks.contains(e.target)) {
                        navLinks.classList.remove('active');
                        navToggle.setAttribute('aria-expanded', 'false');
                        navToggle.textContent = '☰';
                    }
                });
            }
        }
        
        async function checkAuthStatus() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                
                if (session) {
                    updateNavForLoggedInUser();
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
            }
        }
        
        function updateNavForLoggedInUser() {
            const adminLink = document.querySelector('a[href="admin.html"]');
            if (adminLink) {
                adminLink.textContent = 'Admin Dashboard';
                adminLink.style.color = '#28a745';
                adminLink.style.fontWeight = '600';
            }
        }
    </script>
</head>
<body>
    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Navigation -->
    <nav class="navbar" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html" aria-label="STUDL.IO Home">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="nav-logo-img">
                </a>
            </div>
            <button class="nav-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                ☰
            </button>
            <div class="nav-links" role="menubar">
                <a href="index.html#app-visuals" role="menuitem">App Preview</a>
                <a href="index.html#features" role="menuitem">Features</a>
                <a href="index.html#download" role="menuitem">Download</a>
                <a href="index.html#contact" role="menuitem">Contact</a>
                <a href="protocols.html" class="active" role="menuitem">Biohacking Database</a>
                <div class="social-links">
                    <a href="https://www.youtube.com/@studlio" target="_blank" rel="noopener noreferrer" aria-label="Follow us on YouTube" class="social-link">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                        </svg>
                    </a>
                    <a href="https://www.instagram.com/studlio2025/" target="_blank" rel="noopener noreferrer" aria-label="Follow us on Instagram" class="social-link">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
                        </svg>
                    </a>
                    <a href="https://www.tiktok.com/@studl.io" target="_blank" rel="noopener noreferrer" aria-label="Follow us on TikTok" class="social-link">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-1.43.08-2.86-.31-4.08-1.03-2.02-1.19-3.44-3.37-3.65-5.71-.02-.5-.03-1-.01-1.49.18-1.9 1.12-3.72 2.58-4.96 1.66-1.44 3.98-2.13 6.15-1.72.02 1.48-.04 2.96-.04 4.44-.99-.32-2.15-.23-3.02.37-.63.41-1.11 1.04-1.36 1.75-.21.51-.15 1.07-.14 1.61.24 1.64 1.82 3.02 3.5 2.87 1.12-.01 2.19-.66 2.77-1.61.19-.33.4-.67.41-1.06.1-1.79.06-3.57.07-5.36.01-4.03-.01-8.05.02-12.07z"/>
                        </svg>
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Development Status Banner -->
    <div class="dev-banner">
        <div class="container">
            <p>🚧 <strong>Coming Soon!</strong> STUDL.IO is currently in development and will be available soon. Stay tuned for updates!</p>
        </div>
    </div>

    <!-- Protocols Section -->
    <section id="main-content" class="protocols">
        <div class="container">
            <div class="protocols-header">
                <h1 class="section-title">Biohacking Protocols</h1>
                <p class="protocols-subtitle">Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.</p>
                
                <!-- Search Bar -->
                <div class="search-container">
                    <div class="search-input-wrapper">
                        <input 
                            type="text" 
                            id="searchInput" 
                            class="search-input" 
                            placeholder="Search protocols by name, category, or metrics..."
                            autocomplete="off"
                        >
                        <div class="search-icon">🔍</div>
                    </div>
                    
                    <!-- Filters -->
                    <div class="filter-container">
                        <select id="categoryFilter" class="category-dropdown">
                            <option value="">All Categories</option>
                        </select>
                        <select id="sortFilter" class="category-dropdown">
                            <option value="featured-date">Featured & Date</option>
                            <option value="name-asc">Name (A-Z)</option>
                            <option value="name-desc">Name (Z-A)</option>
                            <option value="date-desc">Date (Newest)</option>
                            <option value="date-asc">Date (Oldest)</option>
                        </select>
                    </div>
                    
                    <div id="searchResults" class="search-results-info"></div>
                </div>
            </div>
            
            <!-- Loading State -->
            <div id="loading" class="loading-state">
                <div class="loading-spinner"></div>
                <p>Loading protocols...</p>
            </div>
            
            <!-- Error State -->
            <div id="error" class="error-state" style="display: none;">
                <div class="error-icon">⚠️</div>
                <h3>Unable to load protocols</h3>
                <p>There was an error connecting to our database. Please try again later.</p>
                <button onclick="loadProtocols()" class="btn btn-primary">Try Again</button>
            </div>
            
            <!-- Protocols Grid -->
            <div id="protocols-grid" class="protocols-grid" style="display: none;">
                <!-- Protocols will be dynamically inserted here -->
            </div>
            
            <!-- Empty State -->
            <div id="empty-state" class="empty-state" style="display: none;">
                <div class="empty-icon">📋</div>
                <h3>No protocols available</h3>
                <p>Check back soon for new biohacking protocols!</p>
            </div>
            
            <!-- No Search Results State -->
            <div id="no-search-results" class="no-search-results" style="display: none;">
                <div class="empty-icon">🔍</div>
                <h3>No protocols found</h3>
                <p>Try adjusting your search terms or browse all protocols.</p>
                <button onclick="clearSearch()" class="btn btn-secondary">Clear Search</button>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="footer-logo-img">
                </div>
                <div class="footer-links">
                    <a href="index.html#app-visuals">App Preview</a>
                    <a href="index.html#features">Features</a>
                    <a href="index.html#download">Download</a>
                    <a href="index.html#contact">Contact</a>
                    <a href="protocols.html">Biohacking Database</a>
                    <a href="admin.html">Admin</a>
                    <a href="privacy-policy.html">Privacy Policy</a>
                    <a href="terms-of-service.html">Terms of Service</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 STUDL.IO. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        // Supabase client is already initialized in the head section
        
        // Global variables for search functionality
        let allProtocols = [];
        let allMetricsMap = {};
        
        // Load protocols from Supabase
        async function loadProtocols() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const protocolsGridEl = document.getElementById('protocols-grid');
            const emptyStateEl = document.getElementById('empty-state');
            
            try {
                // Show loading state
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                protocolsGridEl.style.display = 'none';
                emptyStateEl.style.display = 'none';
                
                // Fetch protocols from Supabase
                const { data: protocols, error: protocolsError } = await supabase
                    .from('protocols')
                    .select('*')
                    .order('featured', { ascending: false, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (protocolsError) {
                    throw protocolsError;
                }
                
                // Fetch all health metrics
                const { data: healthMetrics, error: metricsError } = await supabase
                    .from('health_metrics')
                    .select('id, name, unit');
                
                if (metricsError) {
                    throw metricsError;
                }
                
                // Create a map of metric IDs to metric names for quick lookup
                const metricsMap = {};
                if (healthMetrics) {
                    healthMetrics.forEach(metric => {
                        metricsMap[metric.id] = {
                            name: metric.name,
                            unit: metric.unit
                        };
                    });
                }
                
                // Store data globally for search functionality
                allProtocols = protocols || [];
                allMetricsMap = metricsMap;
                
                // Debug: Log featured protocols and protocol IDs
                console.log('Featured protocols:', protocols.filter(p => p.featured === true).map(p => p.name));
                console.log('Protocol IDs:', protocols.map(p => ({ id: p.id, name: p.name })));
                
                // Hide loading state
                loadingEl.style.display = 'none';
                
                if (!protocols || protocols.length === 0) {
                    // Show empty state
                    emptyStateEl.style.display = 'block';
                } else {
                    // Sort protocols using the current sort option
                    const sortedProtocols = sortProtocols([...protocols]);
                    
                    // Populate category dropdown
                    populateCategoryDropdown(sortedProtocols);
                    
                    // Display protocols with metric information
                    displayProtocols(sortedProtocols, metricsMap);
                    protocolsGridEl.style.display = 'grid';
                    updateSearchResults(sortedProtocols.length, sortedProtocols.length);
                }
                
            } catch (error) {
                console.error('Error loading protocols:', error);
                
                // Show error state
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
            }
        }
        
        // Display protocols in the grid
        function displayProtocols(protocols, metricsMap) {
            const protocolsGridEl = document.getElementById('protocols-grid');
            console.log('Displaying protocols:', protocols.length);
            console.log('First protocol ID:', protocols[0]?.id);
            
            protocolsGridEl.innerHTML = protocols.map(protocol => {
                // Get the actual metric names for this protocol
                const metricNames = [];
                if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                    protocol.metric_ids.forEach(metricId => {
                        if (metricsMap[metricId]) {
                            metricNames.push(metricsMap[metricId].name);
                        }
                    });
                }
                
                // Generate citations HTML if they exist
                let citationsHtml = '';
                if (protocol.citations && protocol.citations.length > 0) {
                    citationsHtml = `
                        <div class="protocol-citations">
                            <h4 class="citations-title">References:</h4>
                            <ul class="citations-list">
                                ${protocol.citations.map(citation => `
                                    <li class="citation-item">
                                        <a href="${escapeHtml(citation.url)}" target="_blank" rel="noopener noreferrer" class="citation-link">
                                            ${escapeHtml(citation.name)}
                                        </a>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                }
                
                const protocolId = protocol.id || 'unknown';
                // Create tags array
                const tags = [];
                if (protocol.featured) tags.push('Featured');
                if (protocol.category) tags.push(protocol.category);
                
                // Truncate description to 3 lines
                let description = protocol.description || 'No description available.';
                const lines = description.split('\n');
                if (lines.length > 3) {
                    description = lines.slice(0, 3).join('\n') + '...';
                }
                
                return `
                <div class="protocol-card ${protocol.featured ? 'featured-protocol' : ''}" onclick="viewProtocolDetails('${protocolId}')">
                    <div class="protocol-header">
                        <h3 class="protocol-title">${escapeHtml(protocol.name || 'Untitled Protocol')}</h3>
                        ${protocol.featured ? '<span class="featured-badge">Featured</span>' : ''}
                    </div>
                    <div class="protocol-content">
                        <div class="protocol-description">${convertMarkdownToHtml(description)}</div>
                    </div>
                    <div class="protocol-footer">
                        <div class="protocol-tags">
                            ${tags.filter(tag => tag !== 'Featured').map(tag => {
                                // Convert category name to CSS class
                                const categoryClass = tag.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                                return `<span class="protocol-tag category-${categoryClass}">${escapeHtml(tag)}</span>`;
                            }).join('')}
                        </div>
                        <button class="btn btn-sm btn-primary protocol-open-btn">Open Protocol</button>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to convert markdown to HTML
        function convertMarkdownToHtml(text) {
            if (!text) return text;
            
            // Convert markdown formatting to HTML
            let html = text;
            
            // Headers: # ## ### #### ##### ######
            html = html.replace(/^#{6}\s+(.*)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#{5}\s+(.*)$/gm, '<h5>$1</h5>');
            html = html.replace(/^#{4}\s+(.*)$/gm, '<h4>$1</h4>');
            html = html.replace(/^#{3}\s+(.*)$/gm, '<h3>$1</h3>');
            html = html.replace(/^#{2}\s+(.*)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#{1}\s+(.*)$/gm, '<h1>$1</h1>');
            
            // Bold text: **text** or __text__
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            
            // Italic text: *text* or _text_
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // Code: `code`
            html = html.replace(/`(.*?)`/g, '<code>$1</code>');
            
            // Clean up leading/trailing whitespace and newlines
            html = html.trim();
            
            // Handle line breaks more carefully
            if (html.includes('\n\n')) {
                // Multiple paragraphs: Convert double newlines to paragraph breaks
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
            } else {
                // Single paragraph: Convert single newlines to <br>
                html = html.replace(/\n/g, '<br>');
                html = '<p>' + html + '</p>';
            }
            
            // URLs: Convert to clickable links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            html = html.replace(urlRegex, (url) => {
                // Create a shortened display text
                let displayText = url;
                
                // Remove protocol for display
                if (url.startsWith('https://')) {
                    displayText = url.substring(8);
                } else if (url.startsWith('http://')) {
                    displayText = url.substring(7);
                }
                
                // Truncate if too long (keep first part and last part)
                if (displayText.length > 50) {
                    const firstPart = displayText.substring(0, 30);
                    const lastPart = displayText.substring(displayText.length - 20);
                    displayText = firstPart + '...' + lastPart;
                }
                
                // Return clickable link
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" class="protocol-link">${escapeHtml(displayText)}</a>`;
            });
            
            return html;
        }
        
        // Legacy function for backward compatibility
        function convertUrlsToLinks(text) {
            return convertMarkdownToHtml(text);
        }
        
        // Helper function to format date
        function formatDate(dateString) {
            if (!dateString) return 'Unknown date';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }
        
        // Populate category dropdown
        function populateCategoryDropdown(protocols) {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(protocols.map(p => p.category).filter(Boolean))].sort();
            
            // Clear existing options except "All Categories"
            categoryFilter.innerHTML = '<option value="">All Categories</option>';
            
            // Add category options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }
        
        // Sort protocols based on selected sort option
        function sortProtocols(protocols) {
            const sortFilter = document.getElementById('sortFilter');
            const sortOption = sortFilter ? sortFilter.value : 'featured-date';
            
            console.log('Sorting protocols with option:', sortOption);
            
            return protocols.sort((a, b) => {
                switch (sortOption) {
                    case 'featured-date':
                        // Default: Featured first, then by creation date (newest first)
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'name-asc':
                        // Sort by name A-Z
                        return (a.name || '').localeCompare(b.name || '');
                    
                    case 'name-desc':
                        // Sort by name Z-A
                        return (b.name || '').localeCompare(a.name || '');
                    
                    case 'date-desc':
                        // Sort by date newest first
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'date-asc':
                        // Sort by date oldest first
                        return new Date(a.created_at) - new Date(b.created_at);
                    
                    default:
                        // Default sorting
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                }
            });
        }
        
        // Combined search and filter functionality
        function filterProtocols() {
            const searchTerm = document.getElementById('searchInput').value;
            const selectedCategory = document.getElementById('categoryFilter').value;
            
            let filteredProtocols = allProtocols;
            
            // Apply category filter
            if (selectedCategory) {
                filteredProtocols = filteredProtocols.filter(protocol => 
                    protocol.category === selectedCategory
                );
            }
            
            // Apply search filter
            if (searchTerm && searchTerm.trim() !== '') {
                const searchLower = searchTerm.toLowerCase();
                filteredProtocols = filteredProtocols.filter(protocol => {
                    // Search in protocol name
                    if (protocol.name && protocol.name.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in category
                    if (protocol.category && protocol.category.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in description
                    if (protocol.description && protocol.description.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in metric names
                    if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                        const hasMatchingMetric = protocol.metric_ids.some(metricId => {
                            const metric = allMetricsMap[metricId];
                            return metric && metric.name.toLowerCase().includes(searchLower);
                        });
                        if (hasMatchingMetric) {
                            return true;
                        }
                    }
                    
                    // Search in citations
                    if (protocol.citations && protocol.citations.length > 0) {
                        const hasMatchingCitation = protocol.citations.some(citation => 
                            citation.name && citation.name.toLowerCase().includes(searchLower)
                        );
                        if (hasMatchingCitation) {
                            return true;
                        }
                    }
                    
                    return false;
                });
            }
            
            // Apply sorting to filtered protocols
            filteredProtocols = sortProtocols(filteredProtocols);
            
            // Update display
            if (filteredProtocols.length === 0) {
                document.getElementById('protocols-grid').style.display = 'none';
                document.getElementById('no-search-results').style.display = 'block';
            } else {
                displayProtocols(filteredProtocols, allMetricsMap);
                document.getElementById('protocols-grid').style.display = 'grid';
                document.getElementById('no-search-results').style.display = 'none';
            }
            
            updateSearchResults(filteredProtocols.length, allProtocols.length);
        }
        
        // Legacy search function for backward compatibility
        function searchProtocols(searchTerm) {
            filterProtocols();
        }
        
        // Update search results counter
        function updateSearchResults(shown, total) {
            const searchResultsEl = document.getElementById('searchResults');
            if (shown === total) {
                searchResultsEl.textContent = '';
            } else {
                searchResultsEl.textContent = `Showing ${shown} of ${total} protocols`;
            }
        }
        
        // Clear search and filters
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            const categoryFilter = document.getElementById('categoryFilter');
            const sortFilter = document.getElementById('sortFilter');
            searchInput.value = '';
            categoryFilter.value = '';
            sortFilter.value = 'featured-date'; // Reset to default sort
            filterProtocols();
        }
        
        // Function to view protocol details
        function viewProtocolDetails(protocolId) {
            console.log('Clicked protocol with ID:', protocolId);
            
            // Navigate directly to protocol detail page
            window.location.href = `protocol-detail.html?id=${protocolId}`;
        }
        
        
        // Load protocols when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, starting to load protocols...');
            loadProtocols();
            
            // Add search event listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', () => {
                filterProtocols();
            });
            
            // Add category filter event listener
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.addEventListener('change', () => {
                filterProtocols();
            });
            
            // Add sort filter event listener
            const sortFilter = document.getElementById('sortFilter');
            sortFilter.addEventListener('change', () => {
                filterProtocols();
            });
        });
    </script>
</body>
</html>
