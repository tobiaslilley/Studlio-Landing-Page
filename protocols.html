<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocols - STUDL.IO</title>
    <meta name="description" content="Browse and explore health protocols available in STUDL.IO">
    
    <!-- OpenGraph Meta Tags -->
    <meta property="og:title" content="Health Protocols - STUDL.IO">
    <meta property="og:description" content="Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.">
    <meta property="og:image" content="https://studl.io/Assets/opengraph.png">
    <meta property="og:url" content="https://studl.io/protocols.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="STUDL.IO">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Health Protocols - STUDL.IO">
    <meta name="twitter:description" content="Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.">
    <meta name="twitter:image" content="Assets/opengraph.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="Assets/Website-Favicon-Color.svg">
    
    <!-- Preload fonts for better performance -->
    <link rel="preload" href="Assets/Sanger.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="Assets/Cartograph-Sans-Light.ttf" as="font" type="font/ttf" crossorigin>
    
    <!-- CSS -->
    <link rel="stylesheet" href="styles.css">
    
    <!-- Supabase -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://htizxlmrzfehvpupvwbn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh0aXp4bG1yemZlaHZwdXB2d2JuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMTY3NDEsImV4cCI6MjA3MTY5Mjc0MX0.pBC8d5zXG6DZeU3atMZEqOgY4WG8Mh7T0m2tVk5CcUY';
        
        // Initialize Supabase client
        let supabase;
        if (window.supabase) {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } else {
            console.error('Supabase client not loaded');
        }
        
        // Check authentication status
        document.addEventListener('DOMContentLoaded', async () => {
            await checkAuthStatus();
        });
        
        async function checkAuthStatus() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                
                if (session) {
                    updateNavForLoggedInUser();
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
            }
        }
        
        function updateNavForLoggedInUser() {
            const adminLink = document.querySelector('a[href="admin.html"]');
            if (adminLink) {
                adminLink.textContent = 'Admin Dashboard';
                adminLink.style.color = '#28a745';
                adminLink.style.fontWeight = '600';
            }
        }
    </script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <a href="index.html">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="nav-logo-img">
                </a>
            </div>
            <div class="nav-links">
                <a href="index.html#features">Features</a>
                <a href="index.html#download">Download</a>
                <a href="index.html#contact">Contact</a>
                <a href="protocols.html" class="active">Protocols</a>
            </div>
        </div>
    </nav>

    <!-- Development Status Banner -->
    <div class="dev-banner">
        <div class="container">
            <p>üöß <strong>Coming Soon!</strong> STUDL.IO is currently in development and will be available soon. Stay tuned for updates!</p>
        </div>
    </div>

    <!-- Protocols Section -->
    <section class="protocols">
        <div class="container">
            <div class="protocols-header">
                <h1 class="section-title">Health Protocols</h1>
                <p class="protocols-subtitle">Explore our collection of health optimization protocols. Each protocol is designed to help you track and optimize specific aspects of your health journey.</p>
                
                <!-- Search Bar -->
                <div class="search-container">
                    <div class="search-input-wrapper">
                        <input 
                            type="text" 
                            id="searchInput" 
                            class="search-input" 
                            placeholder="Search protocols by name, category, or metrics..."
                            autocomplete="off"
                        >
                        <div class="search-icon">üîç</div>
                    </div>
                    
                    <!-- Filters -->
                    <div class="filter-container">
                        <select id="categoryFilter" class="category-dropdown">
                            <option value="">All Categories</option>
                        </select>
                        <select id="sortFilter" class="category-dropdown">
                            <option value="featured-date">Featured & Date</option>
                            <option value="name-asc">Name (A-Z)</option>
                            <option value="name-desc">Name (Z-A)</option>
                            <option value="date-desc">Date (Newest)</option>
                            <option value="date-asc">Date (Oldest)</option>
                        </select>
                    </div>
                    
                    <div id="searchResults" class="search-results-info"></div>
                </div>
            </div>
            
            <!-- Loading State -->
            <div id="loading" class="loading-state">
                <div class="loading-spinner"></div>
                <p>Loading protocols...</p>
            </div>
            
            <!-- Error State -->
            <div id="error" class="error-state" style="display: none;">
                <div class="error-icon">‚ö†Ô∏è</div>
                <h3>Unable to load protocols</h3>
                <p>There was an error connecting to our database. Please try again later.</p>
                <button onclick="loadProtocols()" class="btn btn-primary">Try Again</button>
            </div>
            
            <!-- Protocols Grid -->
            <div id="protocols-grid" class="protocols-grid" style="display: none;">
                <!-- Protocols will be dynamically inserted here -->
            </div>
            
            <!-- Empty State -->
            <div id="empty-state" class="empty-state" style="display: none;">
                <div class="empty-icon">üìã</div>
                <h3>No protocols available</h3>
                <p>Check back soon for new health protocols!</p>
            </div>
            
            <!-- No Search Results State -->
            <div id="no-search-results" class="no-search-results" style="display: none;">
                <div class="empty-icon">üîç</div>
                <h3>No protocols found</h3>
                <p>Try adjusting your search terms or browse all protocols.</p>
                <button onclick="clearSearch()" class="btn btn-secondary">Clear Search</button>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <img src="Assets/Title-Only-Transparent.png" alt="STUDL.IO" class="footer-logo-img">
                </div>
                <div class="footer-links">
                    <a href="index.html#features">Features</a>
                    <a href="index.html#download">Download</a>
                    <a href="index.html#contact">Contact</a>
                    <a href="protocols.html">Protocols</a>
                    <a href="admin.html">Admin</a>
                    <a href="privacy-policy.html">Privacy Policy</a>
                    <a href="terms-of-service.html">Terms of Service</a>
                    <a href="https://x.com/studl_io" target="_blank" rel="noopener noreferrer">Follow on X</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 STUDL.IO. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        // Supabase client is already initialized in the head section
        
        // Global variables for search functionality
        let allProtocols = [];
        let allMetricsMap = {};
        
        // Load protocols from Supabase
        async function loadProtocols() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const protocolsGridEl = document.getElementById('protocols-grid');
            const emptyStateEl = document.getElementById('empty-state');
            
            try {
                // Show loading state
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                protocolsGridEl.style.display = 'none';
                emptyStateEl.style.display = 'none';
                
                // Fetch protocols from Supabase
                const { data: protocols, error: protocolsError } = await supabase
                    .from('protocols')
                    .select('*')
                    .order('featured', { ascending: false, nullsFirst: false })
                    .order('created_at', { ascending: false });
                
                if (protocolsError) {
                    throw protocolsError;
                }
                
                // Fetch all health metrics
                const { data: healthMetrics, error: metricsError } = await supabase
                    .from('health_metrics')
                    .select('id, name, unit');
                
                if (metricsError) {
                    throw metricsError;
                }
                
                // Create a map of metric IDs to metric names for quick lookup
                const metricsMap = {};
                if (healthMetrics) {
                    healthMetrics.forEach(metric => {
                        metricsMap[metric.id] = {
                            name: metric.name,
                            unit: metric.unit
                        };
                    });
                }
                
                // Store data globally for search functionality
                allProtocols = protocols || [];
                allMetricsMap = metricsMap;
                
                // Debug: Log featured protocols and protocol IDs
                console.log('Featured protocols:', protocols.filter(p => p.featured === true).map(p => p.name));
                console.log('Protocol IDs:', protocols.map(p => ({ id: p.id, name: p.name })));
                
                // Hide loading state
                loadingEl.style.display = 'none';
                
                if (!protocols || protocols.length === 0) {
                    // Show empty state
                    emptyStateEl.style.display = 'block';
                } else {
                    // Sort protocols using the current sort option
                    const sortedProtocols = sortProtocols([...protocols]);
                    
                    // Populate category dropdown
                    populateCategoryDropdown(sortedProtocols);
                    
                    // Display protocols with metric information
                    displayProtocols(sortedProtocols, metricsMap);
                    protocolsGridEl.style.display = 'grid';
                    updateSearchResults(sortedProtocols.length, sortedProtocols.length);
                }
                
            } catch (error) {
                console.error('Error loading protocols:', error);
                
                // Show error state
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
            }
        }
        
        // Display protocols in the grid
        function displayProtocols(protocols, metricsMap) {
            const protocolsGridEl = document.getElementById('protocols-grid');
            console.log('Displaying protocols:', protocols.length);
            console.log('First protocol ID:', protocols[0]?.id);
            
            protocolsGridEl.innerHTML = protocols.map(protocol => {
                // Get the actual metric names for this protocol
                const metricNames = [];
                if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                    protocol.metric_ids.forEach(metricId => {
                        if (metricsMap[metricId]) {
                            metricNames.push(metricsMap[metricId].name);
                        }
                    });
                }
                
                // Generate citations HTML if they exist
                let citationsHtml = '';
                if (protocol.citations && protocol.citations.length > 0) {
                    citationsHtml = `
                        <div class="protocol-citations">
                            <h4 class="citations-title">References:</h4>
                            <ul class="citations-list">
                                ${protocol.citations.map(citation => `
                                    <li class="citation-item">
                                        <a href="${escapeHtml(citation.url)}" target="_blank" rel="noopener noreferrer" class="citation-link">
                                            ${escapeHtml(citation.name)}
                                        </a>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                }
                
                const protocolId = protocol.id || 'unknown';
                // Create tags array
                const tags = [];
                if (protocol.featured) tags.push('Featured');
                if (protocol.category) tags.push(protocol.category);
                
                // Truncate description to 3 lines
                let description = protocol.description || 'No description available.';
                const lines = description.split('\n');
                if (lines.length > 3) {
                    description = lines.slice(0, 3).join('\n') + '...';
                }
                
                return `
                <div class="protocol-card ${protocol.featured ? 'featured-protocol' : ''}" onclick="viewProtocolDetails('${protocolId}')">
                    <div class="protocol-header">
                        <h3 class="protocol-title">${escapeHtml(protocol.name || 'Untitled Protocol')}</h3>
                        ${protocol.featured ? '<span class="featured-badge">Featured</span>' : ''}
                    </div>
                    <div class="protocol-content">
                        <div class="protocol-description">${convertMarkdownToHtml(description)}</div>
                    </div>
                    <div class="protocol-footer">
                        <div class="protocol-tags">
                            ${tags.filter(tag => tag !== 'Featured').map(tag => {
                                // Convert category name to CSS class
                                const categoryClass = tag.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                                return `<span class="protocol-tag category-${categoryClass}">${escapeHtml(tag)}</span>`;
                            }).join('')}
                        </div>
                        <button class="btn btn-sm btn-primary protocol-open-btn">Open Protocol</button>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to convert markdown to HTML
        function convertMarkdownToHtml(text) {
            if (!text) return text;
            
            // Convert markdown formatting to HTML
            let html = text;
            
            // Headers: # ## ### #### ##### ######
            html = html.replace(/^#{6}\s+(.*)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#{5}\s+(.*)$/gm, '<h5>$1</h5>');
            html = html.replace(/^#{4}\s+(.*)$/gm, '<h4>$1</h4>');
            html = html.replace(/^#{3}\s+(.*)$/gm, '<h3>$1</h3>');
            html = html.replace(/^#{2}\s+(.*)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#{1}\s+(.*)$/gm, '<h1>$1</h1>');
            
            // Bold text: **text** or __text__
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>');
            
            // Italic text: *text* or _text_
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');
            
            // Code: `code`
            html = html.replace(/`(.*?)`/g, '<code>$1</code>');
            
            // Clean up leading/trailing whitespace and newlines
            html = html.trim();
            
            // Handle line breaks more carefully
            if (html.includes('\n\n')) {
                // Multiple paragraphs: Convert double newlines to paragraph breaks
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
            } else {
                // Single paragraph: Convert single newlines to <br>
                html = html.replace(/\n/g, '<br>');
                html = '<p>' + html + '</p>';
            }
            
            // URLs: Convert to clickable links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            html = html.replace(urlRegex, (url) => {
                // Create a shortened display text
                let displayText = url;
                
                // Remove protocol for display
                if (url.startsWith('https://')) {
                    displayText = url.substring(8);
                } else if (url.startsWith('http://')) {
                    displayText = url.substring(7);
                }
                
                // Truncate if too long (keep first part and last part)
                if (displayText.length > 50) {
                    const firstPart = displayText.substring(0, 30);
                    const lastPart = displayText.substring(displayText.length - 20);
                    displayText = firstPart + '...' + lastPart;
                }
                
                // Return clickable link
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" class="protocol-link">${escapeHtml(displayText)}</a>`;
            });
            
            return html;
        }
        
        // Legacy function for backward compatibility
        function convertUrlsToLinks(text) {
            return convertMarkdownToHtml(text);
        }
        
        // Helper function to format date
        function formatDate(dateString) {
            if (!dateString) return 'Unknown date';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }
        
        // Populate category dropdown
        function populateCategoryDropdown(protocols) {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(protocols.map(p => p.category).filter(Boolean))].sort();
            
            // Clear existing options except "All Categories"
            categoryFilter.innerHTML = '<option value="">All Categories</option>';
            
            // Add category options
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }
        
        // Sort protocols based on selected sort option
        function sortProtocols(protocols) {
            const sortFilter = document.getElementById('sortFilter');
            const sortOption = sortFilter ? sortFilter.value : 'featured-date';
            
            console.log('Sorting protocols with option:', sortOption);
            
            return protocols.sort((a, b) => {
                switch (sortOption) {
                    case 'featured-date':
                        // Default: Featured first, then by creation date (newest first)
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'name-asc':
                        // Sort by name A-Z
                        return (a.name || '').localeCompare(b.name || '');
                    
                    case 'name-desc':
                        // Sort by name Z-A
                        return (b.name || '').localeCompare(a.name || '');
                    
                    case 'date-desc':
                        // Sort by date newest first
                        return new Date(b.created_at) - new Date(a.created_at);
                    
                    case 'date-asc':
                        // Sort by date oldest first
                        return new Date(a.created_at) - new Date(b.created_at);
                    
                    default:
                        // Default sorting
                        if (a.featured === true && b.featured !== true) return -1;
                        if (a.featured !== true && b.featured === true) return 1;
                        return new Date(b.created_at) - new Date(a.created_at);
                }
            });
        }
        
        // Combined search and filter functionality
        function filterProtocols() {
            const searchTerm = document.getElementById('searchInput').value;
            const selectedCategory = document.getElementById('categoryFilter').value;
            
            let filteredProtocols = allProtocols;
            
            // Apply category filter
            if (selectedCategory) {
                filteredProtocols = filteredProtocols.filter(protocol => 
                    protocol.category === selectedCategory
                );
            }
            
            // Apply search filter
            if (searchTerm && searchTerm.trim() !== '') {
                const searchLower = searchTerm.toLowerCase();
                filteredProtocols = filteredProtocols.filter(protocol => {
                    // Search in protocol name
                    if (protocol.name && protocol.name.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in category
                    if (protocol.category && protocol.category.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in description
                    if (protocol.description && protocol.description.toLowerCase().includes(searchLower)) {
                        return true;
                    }
                    
                    // Search in metric names
                    if (protocol.metric_ids && protocol.metric_ids.length > 0) {
                        const hasMatchingMetric = protocol.metric_ids.some(metricId => {
                            const metric = allMetricsMap[metricId];
                            return metric && metric.name.toLowerCase().includes(searchLower);
                        });
                        if (hasMatchingMetric) {
                            return true;
                        }
                    }
                    
                    // Search in citations
                    if (protocol.citations && protocol.citations.length > 0) {
                        const hasMatchingCitation = protocol.citations.some(citation => 
                            citation.name && citation.name.toLowerCase().includes(searchLower)
                        );
                        if (hasMatchingCitation) {
                            return true;
                        }
                    }
                    
                    return false;
                });
            }
            
            // Apply sorting to filtered protocols
            filteredProtocols = sortProtocols(filteredProtocols);
            
            // Update display
            if (filteredProtocols.length === 0) {
                document.getElementById('protocols-grid').style.display = 'none';
                document.getElementById('no-search-results').style.display = 'block';
            } else {
                displayProtocols(filteredProtocols, allMetricsMap);
                document.getElementById('protocols-grid').style.display = 'grid';
                document.getElementById('no-search-results').style.display = 'none';
            }
            
            updateSearchResults(filteredProtocols.length, allProtocols.length);
        }
        
        // Legacy search function for backward compatibility
        function searchProtocols(searchTerm) {
            filterProtocols();
        }
        
        // Update search results counter
        function updateSearchResults(shown, total) {
            const searchResultsEl = document.getElementById('searchResults');
            if (shown === total) {
                searchResultsEl.textContent = '';
            } else {
                searchResultsEl.textContent = `Showing ${shown} of ${total} protocols`;
            }
        }
        
        // Clear search and filters
        function clearSearch() {
            const searchInput = document.getElementById('searchInput');
            const categoryFilter = document.getElementById('categoryFilter');
            const sortFilter = document.getElementById('sortFilter');
            searchInput.value = '';
            categoryFilter.value = '';
            sortFilter.value = 'featured-date'; // Reset to default sort
            filterProtocols();
        }
        
        // Function to view protocol details
        function viewProtocolDetails(protocolId) {
            console.log('Clicked protocol with ID:', protocolId);
            
            // Find the protocol data to get name and description for social sharing
            const protocol = allProtocols.find(p => p.id === protocolId);
            if (protocol) {
                // URL encode the protocol name and description for the URL
                const protocolName = encodeURIComponent(protocol.name || 'Protocol');
                const protocolDescription = encodeURIComponent(protocol.description || '');
                
                // Navigate to protocol detail page with ID, name, and description as parameters
                window.location.href = `protocol-detail.html?id=${protocolId}&name=${protocolName}&description=${protocolDescription}`;
            } else {
                // Fallback to just ID if protocol not found
                window.location.href = `protocol-detail.html?id=${protocolId}`;
            }
        }
        
        
        // Load protocols when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, starting to load protocols...');
            loadProtocols();
            
            // Add search event listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('input', () => {
                filterProtocols();
            });
            
            // Add category filter event listener
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.addEventListener('change', () => {
                filterProtocols();
            });
            
            // Add sort filter event listener
            const sortFilter = document.getElementById('sortFilter');
            sortFilter.addEventListener('change', () => {
                filterProtocols();
            });
        });
    </script>
</body>
</html>
